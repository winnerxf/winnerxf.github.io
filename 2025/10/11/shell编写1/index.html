<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>shell编写 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="今天开始编写一个用c语言写的shell">
<meta property="og:type" content="article">
<meta property="og:title" content="shell编写">
<meta property="og:url" content="http://example.com/2025/10/11/shell%E7%BC%96%E5%86%991/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="今天开始编写一个用c语言写的shell">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-10-11T06:21:43.000Z">
<meta property="article:modified_time" content="2025-10-17T04:28:39.801Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-shell编写1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/11/shell%E7%BC%96%E5%86%991/" class="article-date">
  <time class="dt-published" datetime="2025-10-11T06:21:43.000Z" itemprop="datePublished">2025-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      shell编写
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天开始编写一个用c语言写的shell</p>
<span id="more"></span>

<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>shell的主要做的是三件事：</p>
<ul>
<li>初始化：shell会读取并执行其配置文件</li>
<li>解释：读取命令并执行它们</li>
<li>终止：在执行命令以后，shell会释放内存然后终止</li>
</ul>
<p>但是我现在制作的是最简单的shell，没有自己的配置文件，也不会有关闭命令</p>
<p>因此这个shell只需要不断的调用循环函数，然后终止</p>
<p>首先下面的代码只是一部分，并不可以实现shell(即便是最简单的shell了)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">	<span class="comment">// argc：命令行参数个数</span></span><br><span class="line">    <span class="comment">// argv：命令行参数数组（字符串指针数组）</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Run command loop.</span></span><br><span class="line">  lsh_loop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform any shutdown/cleanup.</span></span><br><span class="line">  <span class="comment">// 程序退出前的清理工作，当前只是注释</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">  <span class="comment">//正常退出程序，EXIT_SUCCESS 通常定义为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中的l s h_l o o p()函数将循环解释命令，以下是实现过程</p>
<hr>
<h2 id="loop函数的实现"><a href="#loop函数的实现" class="headerlink" title="loop函数的实现"></a>loop函数的实现</h2><p>前面的代码只是简单提及了启动的过程，执行loop函数，然后就返回</p>
<p>显而易见核心是loop函数的实现</p>
<p>我们可以思考一下shell会对我们输入的命令做什么：</p>
<ul>
<li><code>read</code>：首先肯定是读取你输入的命令</li>
<li><code>parse</code>：其次就是解析你的命令，如果不解析命令电脑就不理解你输入的命令的含义**(这里的解析命令是把命令分割为程序和参数)**</li>
</ul>
<p>比如命令<code>ls -l</code>这个命令就会被分割为<code>ls</code>和<code>-l</code></p>
<ul>
<li><code>execute</code>：执行解析后的命令</li>
</ul>
<p>这也就是我上面所写的loop函数需要实现的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lsh_loop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="type">char</span> *line;    <span class="comment">// 存储用户输入的一行命令</span></span><br><span class="line">  	<span class="type">char</span> **args;   <span class="comment">// 存储分割后的命令参数数组  字符串指针数组，如 [&quot;ls&quot;, &quot;-l&quot;, NULL]</span></span><br><span class="line">  	<span class="type">int</span> status;    <span class="comment">// 存储命令执行状态   0表示正常退出/停止，非0表示继续</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);                    <span class="comment">// 显示提示符</span></span><br><span class="line">        line = lsh_read_line();          <span class="comment">// 读取输入</span></span><br><span class="line">        args = lsh_split_line(line);     <span class="comment">// 解析命令</span></span><br><span class="line">        status = lsh_execute(args);      <span class="comment">// 执行命令</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(line);</span><br><span class="line">        <span class="built_in">free</span>(args);</span><br><span class="line">    &#125; <span class="keyword">while</span> (status); <span class="comment">// // 根据状态决定是否继续循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="read-line函数"><a href="#read-line函数" class="headerlink" title="read_line函数"></a>read_line函数</h2><p>虽然功能很简单，只是读取你输入的命令，但是用c语言来实现却很麻烦</p>
<p>最难的是你无法提前知道用户会在shell输入多少文本，所以内存的分配是一个问题</p>
<p>这意味着你不可以只是简单的分配一块内存，如果需要的内存超过就需要重新分配更多的内存</p>
<p>实现的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取命令的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSH_RL_BUFSIZE 1024</span></span><br><span class="line"><span class="comment">// 意味着编译器在编译前会把所有LSH_RL_BUFSIZE替换为1024</span></span><br><span class="line"><span class="comment">// 这里表示输入缓冲区的初始大小是 1024 字节</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">lsh_read_line</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bufsize = LSH_RL_BUFSIZE;<span class="comment">//这个变量用于跟踪当前缓冲区的容量</span></span><br><span class="line">    <span class="type">int</span> position = <span class="number">0</span>;<span class="comment">//这个变量用作指针，指示当前在缓冲区中写入字符的位置</span></span><br><span class="line">    <span class="type">char</span> *buffer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * bufsize);</span><br><span class="line">    <span class="comment">//动态分配bufsize个char大小的内存</span></span><br><span class="line">    <span class="type">int</span> c;<span class="comment">//从下面知道用于存储字符</span></span><br><span class="line">    <span class="comment">//使用int而不是char是因为getchar()返回int,需要能存储 EOF(通常是-1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!buffer)</span><br><span class="line">    <span class="comment">//检查内存分配是否成功 !buffer 等价于 buffer == NULL，如果内存分配失败，malloc 会返回 NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">        <span class="comment">//如果内存分配失败，向标准错误流输出错误信息</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="comment">//立即终止程序执行</span></span><br><span class="line">        <span class="comment">//EXIT_FAILURE：预定义的宏，通常值为 1，表示程序异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = getchar();<span class="comment">//读取一个字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//接下来的代码处理文件结束符或换行符的情况</span></span><br><span class="line">        <span class="keyword">if</span>(c == EOF || c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="comment">// EOF 是一个整数，而不是一个字符</span></span><br><span class="line">        <span class="comment">// c == EOF：检查是否是文件结束符（End Of File）</span></span><br><span class="line">        <span class="comment">// c == &#x27;\n&#x27;：检查是否是换行符（用户按了回车键）</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[position] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">//buffer[position]：访问缓冲区中 position 位置的字符</span></span><br><span class="line">            <span class="comment">//&#x27;\0&#x27;：空字符，ASCII 值为 0，表示 C 字符串的结束</span></span><br><span class="line">            <span class="keyword">return</span> buffer;</span><br><span class="line">            <span class="comment">//将包含用户输入字符串的缓冲区返回给调用者</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            buffer[position] = c;</span><br><span class="line">            <span class="comment">//将读取的字符存储到缓冲区的当前位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        position++;</span><br><span class="line">        <span class="comment">//将位置指针向后移动一位，为下一个字符做准备</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来的代码处理缓冲区溢出的情况</span></span><br><span class="line">    <span class="keyword">if</span>(position &gt;= bufsize)</span><br><span class="line">    <span class="comment">//检查当前位置是否达到或超过当前缓冲区容量</span></span><br><span class="line">    &#123;</span><br><span class="line">        bufsize += LSH_RL_BUFSIZE;</span><br><span class="line">        <span class="comment">//扩大缓冲区容量，每次增加 1024 字节</span></span><br><span class="line">        buffer = <span class="built_in">realloc</span>(buffer,bufsize);<span class="comment">//重新分配内存</span></span><br><span class="line">        <span class="comment">//可能会在新的内存位置重新分配，所以需要更新 buffer 指针</span></span><br><span class="line">        <span class="keyword">if</span>(!buffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此函数的核心就是不断的循环读入字符</p>
<p><strong>EOF 是一个整数，而不是一个字符，如果你想检查它，你需要使用 <code>int</code></strong></p>
<p>这很重要，很容易犯错</p>
<p>如果发现读入的字符最后是换行符或者EOF，那就以null终止当前字符并返回，否则就将该字符添加到字符串中</p>
<p>接着我们又会查看下一个字符是否会超出当前的缓冲区大小，如果超出就会重新分配缓冲区</p>
<p>但是实际上在<code>stdio.h</code>的库里有一个<code>getline()</code>的函数可以实现以上代码的大部分工作，所以以下是使用了<code>getline()</code>函数的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read_line函数的另外一种实现</span></span><br><span class="line"><span class="type">char</span>  *<span class="title function_">lsh_read_line</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//getline()函数要求传入的指针初始为 NULL，这样它才会自动分配内存</span></span><br><span class="line">    <span class="type">ssize_t</span> bufsize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ssize_t：有符号大小类型，用于表示大小或字节数</span></span><br><span class="line">    <span class="comment">//设置为 0 表示让 getline() 自动管理缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getline(&amp;line,&amp;bufsize,<span class="built_in">stdin</span>) == <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//&amp;line：传递 line 指针的地址，getline() 会修改这个指针</span></span><br><span class="line">    <span class="comment">//&amp;bufsize：传递缓冲区大小的地址，getline() 会更新这个值</span></span><br><span class="line">    <span class="comment">//== -1：检查 getline() 是否执行失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(feof(<span class="built_in">stdin</span>))</span><br><span class="line">        <span class="comment">//检查是否到达文件末尾（End Of File）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);<span class="comment">//接收到了EOF的情况</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            perror(<span class="string">&quot;readline&quot;</span>);<span class="comment">//输出错误信息</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//异常退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="split-line函数"><a href="#split-line函数" class="headerlink" title="split_line函数"></a>split_line函数</h2><p>在上面，read函数已经做好了，接下来需要的是把读入的命令解析</p>
<p>在我们现在制作的shell中我们添加一个规则，不允许在命令会参数中转义引用或反斜杠，我们只使用空格来分割参数</p>
<p>所以命令<code>echo &quot;this message&quot;</code>并不会打印出<code>this message</code>，而是打印出<code>this</code>和<code>message</code></p>
<p>通过这些简化，我们用空格将他们划分为<code>token</code>，我们可以用标准库中的<code>strtok</code>函数实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析命令的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSH_TOK_BUFSIZE 64</span></span><br><span class="line"><span class="comment">//定义令牌缓冲区的初始大小，设置为 64，表示初始可以存储64个令牌（命令和参数）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSH_TOK_DELIM <span class="string">&quot; \t\r\n\a&quot;</span></span></span><br><span class="line"><span class="comment">//定义分词分隔符字符串包含 空格&quot; &quot; 制表符&quot;\t&quot; 回车&quot;\r&quot; 换行&quot;\n&quot; 响铃&quot;\a&quot;</span></span><br><span class="line"><span class="type">char</span> **<span class="title function_">lsh_split_line</span><span class="params">(<span class="type">char</span> *line)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bufsize = LSH_TOK_BUFSIZE,position = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//bufsize：当前令牌数组的大小，初始为 64</span></span><br><span class="line">    <span class="comment">//position：当前令牌的位置索引，初始为 0</span></span><br><span class="line">    <span class="type">char</span> **tokens = <span class="built_in">malloc</span>(bufsize * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="type">char</span> *token;</span><br><span class="line">    <span class="comment">//声明字符指针 token，用于存储每次分割得到的令牌</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!tokens)<span class="comment">//检查内存分配是否成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="comment">//如果内存分配失败，输出错误信息并退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token = strtok(line,LSH_TOK_DELIM);</span><br><span class="line">    <span class="comment">//strtok(line, LSH_TOK_DELIM)：在 line 中查找第一个不被分隔符包含的令牌</span></span><br><span class="line">    <span class="comment">//例如：&quot;ls -l&quot; → &quot;ls&quot;</span></span><br><span class="line">    <span class="keyword">while</span>(token != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">//当还有令牌可分割时继续循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        tokens[position] = token;</span><br><span class="line">        <span class="comment">//将当前令牌存储到令牌数组中</span></span><br><span class="line">        position++;</span><br><span class="line">        <span class="comment">//位置索引加1，指向下一个空位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(position &gt;= bufsize)<span class="comment">//检查是否超出当前缓冲区容量</span></span><br><span class="line">        &#123;</span><br><span class="line">            bufsize += LSH_TOK_BUFSIZE;</span><br><span class="line">            <span class="comment">//增加缓冲区大小，每次增加 64 个令牌位置</span></span><br><span class="line">            tokens = <span class="built_in">realloc</span>(tokens,bufsize * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">            <span class="comment">//重新分配更大的内存空间</span></span><br><span class="line">            <span class="keyword">if</span>(!tokens)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;<span class="comment">//检查重新分配是否成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>,LSH_TOK_DELIM);</span><br><span class="line">        <span class="comment">//继续分割下一个令牌</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tokens[position] = <span class="literal">NULL</span>;<span class="comment">//在令牌数组末尾添加 NULL 指针，标记数组结束</span></span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段代码和read_line函数非常相似，因为我们使用的相同的策略，也就是拥有缓冲区并动态扩展</p>
<p>但是这一次，我们使用null结尾的指针数组而不是以null结尾的字符数组 来执行操作</p>
<p>在函数开始时，我们通过对<code>strtok</code>函数的调用返回第一个标记的地址，实际上返回的是你给的字符串的地址，且用’\0’放置在每个标记的末尾，</p>
<p>将每个指针存储在字符指针的数组（缓冲区）中</p>
<p>最后，如果有必要，我们可以重新分配字指针数组。重复整个过程直到<code>strtok</code>没有返回任何标记，此时终止读取</p>
<p>最后我们会得到一系列token和存储它的数组(<code>tokens</code>)，接下来就需要执行</p>
<hr>
<h2 id="shell如何启动进程"><a href="#shell如何启动进程" class="headerlink" title="shell如何启动进程"></a>shell如何启动进程</h2><p>现在我们已经来到了shell的核心问题：启动进程</p>
<p>写一个shell意味着我们需要清楚进程发生了什么还有它是如何开始的</p>
<p>所以接下来需要讨论一下类Unix系统中的进程</p>
<p>在Unix上启动进程只要两种方法，第一种(几乎不算)是<code>Init</code>，当Unix计算机启动时，它的内核被加载。当它的内核被加载并初始化时，内核只启动一个进程，这称为<code>Init</code>。这个进程在计算机打开的整个时间长度内运行，并管理加载计算机剩余的计算机有用的进程</p>
<p>因为大部分的程序都不是<code>Init</code>，所以只有一种另外一种启动进程的方式：<code>fork()</code>系统调用</p>
<p>调用此函数事时，操作系统会复制该进程并启动它们运行，原来的进程被称为“父进程”，新的进程被称为“子进程”。</p>
<p><code>fork()</code>会向子进程返回0，并将子进程的进程PID返回给父进程</p>
<p>从本质上讲，这意味着启动新进程的方式就是复制现有的进程</p>
<p>这听起来可能有些问题，典型的，当你想要运行一个新的进程时，你并不仅仅想要运行一个一样的进程，而是运行一个不一样的程序，这就是<code>exec()</code>系统调用的意义所在。</p>
<p>它用一个全新的程序替换了当前正在运行的程序，这意味着当你调用<code>exec()</code>时，操作系统将停止你的进程，加载新的程序，并在其位置启动该程序。进程不会从调用中返回（除非它发生了错误）</p>
<p>通过这两种系统调用，我们有了大多数程序在<code>Unic</code>上运行的基本要素。首先一个现有的进程分为两个的部分，然后子进程使用<code>exec()</code>将自己替换成一个新的进程，父进程可以继续做其他的事情，甚至可以通过系统调用<code>wait()</code>继续对子进程进行访问</p>
<p>接下来就是用于启动进程并执行外部命令的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统调用函数 创建子进程来执行外部命令</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_launch</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid,wpid;<span class="comment">//进程ID变量</span></span><br><span class="line">    <span class="type">int</span> status;<span class="comment">//子进程状态</span></span><br><span class="line"></span><br><span class="line">    pid = fork();<span class="comment">//使用 fork() 系统调用创建子进程</span></span><br><span class="line">    <span class="comment">//返回值：</span></span><br><span class="line">    <span class="comment">//0：在子进程中</span></span><br><span class="line">    <span class="comment">//&gt;0：在父进程中（返回子进程PID）</span></span><br><span class="line">    <span class="comment">//&lt;0：fork失败</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="keyword">if</span>(execvp(args[<span class="number">0</span>],args) == <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//使用execvp()执行命令 args[0]：命令名(如 &quot;ls&quot;)</span></span><br><span class="line">    <span class="comment">//args：参数数组（如 [&quot;ls&quot;, &quot;-l&quot;, NULL]）</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;lsh&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//如果执行失败，打印错误并退出</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;lsh&quot;</span>);<span class="comment">//fork失败并打印错误信息</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            wpid = waitpid(pid,&amp;status,WUNTRACED);</span><br><span class="line">            <span class="comment">//pid：等待的特定子进程</span></span><br><span class="line">            <span class="comment">//&amp;status：存储子进程状态</span></span><br><span class="line">            <span class="comment">//WUNTRACED：也返回已停止的子进程状态</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));</span><br><span class="line">        <span class="comment">//循环条件：直到子进程正常退出或被信号终止</span></span><br><span class="line">        <span class="comment">//WIFEXITED(status)：子进程正常退出</span></span><br><span class="line">        <span class="comment">//WIFSIGNALED(status)：子进程被信号终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在这个函数将使用我们前面解析的参数列表，然后分叉这个进程，并保存返回值(PID)，当<code>fork()</code>成功返回时，此时我们有两个进程并发运行</p>
<p>子进程就会加入if判断的第一种情况(即PID &#x3D;&#x3D; 0)</p>
<p><strong><code>execvp</code> 的工作原理和特点：</strong></p>
<p>在子进程中我们希望能够运行用户的命令，所以我们使用<code>exec()</code>系统调用的变种之一<code>execvp</code>，<code>exec</code>的变种的实现效果都是不同的，有些需要可变数量的字符串参数，有些需要使用字符串列表，还有一些允许你指定运行进程的环境</p>
<p><code>execvp()</code>需要一个程序名称和一个字符串参数的列表（第一个参数必须是程序的名称，而不应该是程序的文件路径），当我们将程序名称传递给它，操作系统将在系统文件路径中去查询它</p>
<p><strong>分解 <code>execvp</code> 这个名字</strong></p>
<p>这个名字可以拆成三部分来理解：</p>
<ol>
<li><strong><code>exec</code></strong>：<br>这是核心，代表“执行”系统调用。它是一系列函数的家族名称。</li>
<li><strong><code>v</code> (vector)</strong>：<br>这表示这个版本的 <code>exec</code> 接受一个<strong>参数数组</strong>（在C语言中就是 <code>char *argv[]</code>）作为参数。<ul>
<li>例如，对于命令 <code>ls -l /home</code>，你需要构建一个这样的数组： <code>[&quot;ls&quot;, &quot;-l&quot;, &quot;/home&quot;, NULL]</code>。<code>argv[0]</code> 必须是程序名本身。</li>
</ul>
</li>
<li><strong><code>p</code> (path)</strong>：<br>这是最方便的一点！它表示你不用告诉系统 <code>ls</code> 这个程序的<strong>完整路径</strong>（比如 <code>/bin/ls</code>）。你只需要提供程序名 <code>&quot;ls&quot;</code>，操作系统会自动在 <strong>PATH 环境变量</strong> 所指定的目录列表（如 <code>/bin</code>, <code>/usr/bin</code> 等）里去搜索这个名叫 <code>ls</code> 的可执行文件</li>
</ol>
<p>如果<code>exec()</code>命令返回了-1(或者实际上，如果它完全返回)，我们就知道存在错误</p>
<p>所以我们用<code>perror</code>打印系统的错误消息以及我们的程序名称，以方便用户知道错误的来源，之后我们退出shell以方便可以继续运行</p>
<p>第二个条件(<code>pid&lt;0</code>)检查<code>fork()</code>是否有错误,如果是这样，我们就会打印它并继续进行–除了告诉用户并让他们决定是否需要退出之外，没有其他的处理办法</p>
<p>第三个条件(<code>pid &gt; 0</code>)意味着<code>fork()</code>成功执行，此时父进程将会待命，我们知道子进程正在运行当前进程，因此父进程需要等待命令的完成，我们使用<code>waitpid()</code>等待进程的状态改变</p>
<p>不过进程的改变可能是由于各种原因，不仅仅只是因为进程终止了，进程可能是因为正常退出了，也可能是因为错误的代码，或是因为信号的终止</p>
<p>所以我们使用<code>waitpid()</code>提供的宏定义等待程序的退出或终止。当函数最终返回1，这意味着我们继续读取命令并执行了</p>
<hr>
<h2 id="shell内置函数"><a href="#shell内置函数" class="headerlink" title="shell内置函数"></a>shell内置函数</h2><p>你可能注意到了<code>lsp_loop</code>函数调用的<code>lsh_execute()</code>，但是在上面，我却又命名了一个函数<code>lsh_launch</code>，这是故意的</p>
<p>大多数的命令在Shell中被解析为程序，但并不是所有，有一些是直接写入Shell中的</p>
<p>原因其实很简单，如果你想要更改当前所在的目录。你需要使用函数<code>chdir()</code></p>
<p>问题是<strong>文件目录是当前进程的一个属性</strong>，所以如果你写一个<code>cd</code>命令来更改目录，它只会更改自己的当前目录，然后终止，父进程的当前目录却会保持不变</p>
<p>相反，shell进程本身需要执行<code>chdir</code>来更新它的当前目录，然后当启动子进程时，它会继承当前的文件目录</p>
<p><strong>进程的工作目录是独立的</strong></p>
<ul>
<li>每个运行中的程序（进程）都有自己的”当前工作目录”属性</li>
<li>子进程会<strong>继承</strong>父进程的当前目录</li>
<li>但子进程改变自己的目录<strong>不会影响</strong>父进程的目录</li>
</ul>
<p>如果<strong>你正在使用 Shell</strong>（比如终端），它有一个当前的工作目录，比如 <code>/home/user</code></p>
<p><strong>如果你把 <code>cd</code> 做成一个独立的外部程序</strong>：</p>
<ul>
<li>Shell 会启动这个 <code>cd</code> 程序</li>
<li><code>cd</code> 程序确实能改变<strong>它自己</strong>的工作目录</li>
<li>但当 <code>cd</code> 程序运行结束后，它就消失了</li>
<li>Shell 的工作目录<strong>没有任何变化</strong>，还是原来的 <code>/home/user</code></li>
</ul>
<p>所以需要cd这样的内置命令</p>
<p><code>exit</code>命令也是一样：它将无法退出调用它的Shell程序，所以这个程序也需要内置在Shell中</p>
<p><strong>核心原因：子进程无法终止父进程</strong></p>
<ol>
<li><strong>如果 <code>exit</code> 是独立程序</strong>：<ul>
<li>Shell 启动 <code>exit</code> 程序</li>
<li><code>exit</code> 程序只能终止<strong>它自己</strong></li>
<li><code>exit</code> 程序运行结束，消失了</li>
<li>但 Shell 进程<strong>仍然在运行</strong>，没有被退出</li>
</ul>
</li>
<li><strong>正确的做法</strong>：<ul>
<li><code>exit</code> 必须是 Shell 内部的命令</li>
<li>当用户输入 <code>exit</code> 时，Shell <strong>自己调用退出函数</strong></li>
<li>这样 Shell 进程才会真正终止</li>
</ul>
</li>
</ol>
<p>此外，许多Shell程序都是通过配置运行配置文件进行的，比如<code>~/.bashrc</code>这些脚本使用更改Shell操作的命令。不过这些命令只有在 shell 进程本身内部实现时才能更改 shell 的操作</p>
<p>所以这意味着我们需要添加一些Shell本身的命令。这里我们添加<code>cd</code>,<code>exit</code>和<code>help</code>程序，以下是它的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cd eexit help(内置shell的函数)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_cd</span><span class="params">(<span class="type">char</span> **args)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_help</span><span class="params">(<span class="type">char</span> **args)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_exit</span><span class="params">(<span class="type">char</span> **args)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置命令列表</span></span><br><span class="line"><span class="type">char</span> *builtin_str[] = &#123;</span><br><span class="line">    <span class="string">&quot;cd&quot;</span>,</span><br><span class="line">    <span class="string">&quot;help&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exit&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*builtin_func[]) (<span class="type">char</span> **) = &#123;</span><br><span class="line">    &amp;lsh_cd,</span><br><span class="line">    &amp;lsh_help,</span><br><span class="line">    &amp;lsh_exit</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_num_builtins</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(builtin_str) / <span class="keyword">sizeof</span>(<span class="type">char</span> *);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_cd</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(args[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh: expected argument to \&quot;cd\&quot;\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(chdir(args[<span class="number">1</span>]) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;lsh&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_help</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stephen Brennan&#x27;s LSH\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type program names and arguments,and hit enter.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The following are built in:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lsh_num_builtins();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %s\n&quot;</span>,builtin_str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Use the man command for information on other programs.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_exit</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这些代码分为三部分，第一部分包含了对函数的提前声明，提供函数原型是为了你可以使用它(不定义函数内容，但声明后可以使用)</p>
<p>下一部分是一个内置命令名称的数组，后面跟着它们对应函数的数组</p>
<p>这样设计是为了将来只需修改这些数组就能添加新的内置命令，而不必在代码中的某个地方编辑庞大的”switch”语句</p>
<p>如果你对 <code>builtin_func</code> 的声明感到困惑，没关系！我也一样。这是一个函数指针数组（这些函数接受字符串数组作为参数并返回一个整数值）。在C语言中，任何涉及函数指针的声明都会变得非常复杂</p>
<p>最后就是实现每个功能，<code>lsh_cd</code>函数首先检查第二个参数是否存在，如果不存在的话就打印错误信息。然后调用<code>chdir()</code>检查是否有误并返回。而<code>lsp_help</code>函数则是打印了作品的信息，还有内置的函数功能。最后<code>lsp_exit</code>函数返回0，作为终止循环的信号</p>
<hr>
<h2 id="lsh-execute函数实现"><a href="#lsh-execute函数实现" class="headerlink" title="lsh_execute函数实现"></a><code>lsh_execute</code>函数实现</h2><p>最后就只有<code>lsh_execute</code>函数没有完成，这个函数将用来调用内置函数，或是用来启动Shell进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行函数lsh_execute</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_execute</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(args[<span class="number">0</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//空指令，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; lsh_num_builtins();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(args[<span class="number">0</span>],builtin_str[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (*builtin_func[i])(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lsh_launch(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这些操作实际上是为了检查你输入的命令是否等于内置函数，如果是的话，就调用它，如果不是的话，将会调用<code>lsh_launch()</code>去启动这个进程。如果用户输入了一个空字符串，则会被警告参数为NULL。所以我们需要检查输入</p>
<hr>
<h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><p>这就是进入 shell 的所有代码。如果您已经阅读过，您应该完全了解 shell 的工作原理。要试用它（在 Linux 机器上），您需要将这些代码段复制到文件 (<code>main.c</code>) 中，然后对其进行编译。将你需要的文件头包含在里面</p>
<p>接下来我将提供我们从文件头中所用到的函数：</p>
<ul>
<li>#include &lt;sys&#x2F;wait.h&gt;<ul>
<li>waitpid() and its macros</li>
</ul>
</li>
<li>#include &lt;unistd.h&gt;<ul>
<li>chdir()</li>
<li>fork()</li>
<li>exec()</li>
<li>pid_t</li>
</ul>
</li>
<li>#include &lt;stdlib.h&gt;<ul>
<li>malloc()</li>
<li>realloc()</li>
<li>free()</li>
<li>exit()</li>
<li>execvp()</li>
<li>EXIT_SUCCESS,EXIT_FAILURE</li>
</ul>
</li>
<li>#include &lt;stdio.h&gt;<ul>
<li>fprintf()</li>
<li>pintf()</li>
<li>stderr</li>
<li>getchar()</li>
<li>perror()</li>
</ul>
</li>
<li>#include &lt;string.h&gt;<ul>
<li>strcmp()</li>
<li>strtok()</li>
</ul>
</li>
</ul>
<hr>
<h2 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h2><p>项目地址：<a target="_blank" rel="noopener" href="https://brennan.io/2015/01/16/write-a-shell-in-c/#fnref:1">教程 - 用 C 编写 shell • Stephen Brennan — Tutorial - Write a Shell in C • Stephen Brennan</a></p>
<p>我相当于是誉抄了一遍代码帮你以我的语言解释一遍，想看的可以去看看</p>
<p>个人的完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  <span class="comment">// 用于 pid_t 类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span>   <span class="comment">// 用于 waitpid, WUNTRACED 等常量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">// 用于 fork, execvp 等函数</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取命令的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSH_RL_BUFSIZE 1024</span></span><br><span class="line"><span class="comment">// 意味着编译器在编译前会把所有LSH_RL_BUFSIZE替换为1024</span></span><br><span class="line"><span class="comment">// 这里表示输入缓冲区的初始大小是 1024 字节</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">lsh_read_line</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bufsize = LSH_RL_BUFSIZE;<span class="comment">//这个变量用于跟踪当前缓冲区的容量</span></span><br><span class="line">    <span class="type">int</span> position = <span class="number">0</span>;<span class="comment">//这个变量用作指针，指示当前在缓冲区中写入字符的位置</span></span><br><span class="line">    <span class="type">char</span> *buffer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * bufsize);</span><br><span class="line">    <span class="comment">//动态分配bufsize个char大小的内存</span></span><br><span class="line">    <span class="type">int</span> c;<span class="comment">//从下面知道用于存储字符</span></span><br><span class="line">    <span class="comment">//使用int而不是char是因为getchar()返回int,需要能存储 EOF(通常是-1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!buffer)</span><br><span class="line">    <span class="comment">//检查内存分配是否成功 !buffer 等价于 buffer == NULL，如果内存分配失败，malloc 会返回 NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">        <span class="comment">//如果内存分配失败，向标准错误流输出错误信息</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="comment">//立即终止程序执行</span></span><br><span class="line">        <span class="comment">//EXIT_FAILURE：预定义的宏，通常值为 1，表示程序异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = getchar();<span class="comment">//读取一个字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//接下来的代码处理文件结束符或换行符的情况</span></span><br><span class="line">        <span class="keyword">if</span>(c == EOF || c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="comment">// EOF 是一个整数，而不是一个字符</span></span><br><span class="line">        <span class="comment">// c == EOF：检查是否是文件结束符（End Of File）</span></span><br><span class="line">        <span class="comment">// c == &#x27;\n&#x27;：检查是否是换行符（用户按了回车键）</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[position] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">//buffer[position]：访问缓冲区中 position 位置的字符</span></span><br><span class="line">            <span class="comment">//&#x27;\0&#x27;：空字符，ASCII 值为 0，表示 C 字符串的结束</span></span><br><span class="line">            <span class="keyword">return</span> buffer;</span><br><span class="line">            <span class="comment">//将包含用户输入字符串的缓冲区返回给调用者</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            buffer[position] = c;</span><br><span class="line">            <span class="comment">//将读取的字符存储到缓冲区的当前位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        position++;</span><br><span class="line">        <span class="comment">//将位置指针向后移动一位，为下一个字符做准备</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来的代码处理缓冲区溢出的情况</span></span><br><span class="line">    <span class="keyword">if</span>(position &gt;= bufsize)</span><br><span class="line">    <span class="comment">//检查当前位置是否达到或超过当前缓冲区容量</span></span><br><span class="line">    &#123;</span><br><span class="line">        bufsize += LSH_RL_BUFSIZE;</span><br><span class="line">        <span class="comment">//扩大缓冲区容量，每次增加 1024 字节</span></span><br><span class="line">        buffer = <span class="built_in">realloc</span>(buffer,bufsize);<span class="comment">//重新分配内存</span></span><br><span class="line">        <span class="comment">//可能会在新的内存位置重新分配，所以需要更新 buffer 指针</span></span><br><span class="line">        <span class="keyword">if</span>(!buffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// //read_line函数的另外一种实现</span></span><br><span class="line"><span class="comment">// char  *lsh_read_line(void)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     char *line = NULL;</span></span><br><span class="line"><span class="comment">//     //getline()函数要求传入的指针初始为 NULL，这样它才会自动分配内存</span></span><br><span class="line"><span class="comment">//     ssize_t bufsize = 0;</span></span><br><span class="line"><span class="comment">//     //ssize_t：有符号大小类型，用于表示大小或字节数</span></span><br><span class="line"><span class="comment">//     //设置为 0 表示让 getline() 自动管理缓冲区大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     if(getline(&amp;line,&amp;bufsize,stdin) == -1)</span></span><br><span class="line"><span class="comment">//     //&amp;line：传递 line 指针的地址，getline() 会修改这个指针</span></span><br><span class="line"><span class="comment">//     //&amp;bufsize：传递缓冲区大小的地址，getline() 会更新这个值</span></span><br><span class="line"><span class="comment">//     //== -1：检查 getline() 是否执行失败</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         if(feof(stdin))</span></span><br><span class="line"><span class="comment">//         //检查是否到达文件末尾（End Of File）</span></span><br><span class="line"><span class="comment">//         &#123;</span></span><br><span class="line"><span class="comment">//             exit(EXIT_SUCCESS);//接收到了EOF的情况</span></span><br><span class="line"><span class="comment">//         &#125;else&#123;</span></span><br><span class="line"><span class="comment">//             perror(&quot;readline&quot;);//输出错误信息</span></span><br><span class="line"><span class="comment">//             exit(EXIT_FAILURE);//异常退出程序</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return line;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解析命令的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSH_TOK_BUFSIZE 64</span></span><br><span class="line"><span class="comment">//定义令牌缓冲区的初始大小，设置为 64，表示初始可以存储64个令牌（命令和参数）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSH_TOK_DELIM <span class="string">&quot; \t\r\n\a&quot;</span></span></span><br><span class="line"><span class="comment">//定义分词分隔符字符串包含 空格&quot; &quot; 制表符&quot;\t&quot; 回车&quot;\r&quot; 换行&quot;\n&quot; 响铃&quot;\a&quot;</span></span><br><span class="line"><span class="type">char</span> **<span class="title function_">lsh_split_line</span><span class="params">(<span class="type">char</span> *line)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bufsize = LSH_TOK_BUFSIZE,position = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//bufsize：当前令牌数组的大小，初始为 64</span></span><br><span class="line">    <span class="comment">//position：当前令牌的位置索引，初始为 0</span></span><br><span class="line">    <span class="type">char</span> **tokens = <span class="built_in">malloc</span>(bufsize * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="type">char</span> *token;</span><br><span class="line">    <span class="comment">//声明字符指针 token，用于存储每次分割得到的令牌</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!tokens)<span class="comment">//检查内存分配是否成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="comment">//如果内存分配失败，输出错误信息并退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token = strtok(line,LSH_TOK_DELIM);</span><br><span class="line">    <span class="comment">//strtok(line, LSH_TOK_DELIM)：在 line 中查找第一个不被分隔符包含的令牌</span></span><br><span class="line">    <span class="comment">//例如：&quot;ls -l&quot; → &quot;ls&quot;</span></span><br><span class="line">    <span class="keyword">while</span>(token != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">//当还有令牌可分割时继续循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        tokens[position] = token;</span><br><span class="line">        <span class="comment">//将当前令牌存储到令牌数组中</span></span><br><span class="line">        position++;</span><br><span class="line">        <span class="comment">//位置索引加1，指向下一个空位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(position &gt;= bufsize)<span class="comment">//检查是否超出当前缓冲区容量</span></span><br><span class="line">        &#123;</span><br><span class="line">            bufsize += LSH_TOK_BUFSIZE;</span><br><span class="line">            <span class="comment">//增加缓冲区大小，每次增加 64 个令牌位置</span></span><br><span class="line">            tokens = <span class="built_in">realloc</span>(tokens,bufsize * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">            <span class="comment">//重新分配更大的内存空间</span></span><br><span class="line">            <span class="keyword">if</span>(!tokens)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;<span class="comment">//检查重新分配是否成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>,LSH_TOK_DELIM);</span><br><span class="line">        <span class="comment">//继续分割下一个令牌</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tokens[position] = <span class="literal">NULL</span>;<span class="comment">//在令牌数组末尾添加 NULL 指针，标记数组结束</span></span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//系统调用函数 创建子进程来执行外部命令</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_launch</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid,wpid;<span class="comment">//进程ID变量</span></span><br><span class="line">    <span class="type">int</span> status;<span class="comment">//子进程状态</span></span><br><span class="line"></span><br><span class="line">    pid = fork();<span class="comment">//使用 fork() 系统调用创建子进程</span></span><br><span class="line">    <span class="comment">//返回值：</span></span><br><span class="line">    <span class="comment">//0：在子进程中</span></span><br><span class="line">    <span class="comment">//&gt;0：在父进程中（返回子进程PID）</span></span><br><span class="line">    <span class="comment">//&lt;0：fork失败</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="keyword">if</span>(execvp(args[<span class="number">0</span>],args) == <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//使用execvp()执行命令 args[0]：命令名(如 &quot;ls&quot;)</span></span><br><span class="line">    <span class="comment">//args：参数数组（如 [&quot;ls&quot;, &quot;-l&quot;, NULL]）</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;lsh&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//如果执行失败，打印错误并退出</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;lsh&quot;</span>);<span class="comment">//fork失败并打印错误信息</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            wpid = waitpid(pid,&amp;status,WUNTRACED);</span><br><span class="line">            <span class="comment">//pid：等待的特定子进程</span></span><br><span class="line">            <span class="comment">//&amp;status：存储子进程状态</span></span><br><span class="line">            <span class="comment">//WUNTRACED：也返回已停止的子进程状态</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));</span><br><span class="line">        <span class="comment">//循环条件：直到子进程正常退出或被信号终止</span></span><br><span class="line">        <span class="comment">//WIFEXITED(status)：子进程正常退出</span></span><br><span class="line">        <span class="comment">//WIFSIGNALED(status)：子进程被信号终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cd eexit help(内置shell的函数)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_cd</span><span class="params">(<span class="type">char</span> **args)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_help</span><span class="params">(<span class="type">char</span> **args)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_exit</span><span class="params">(<span class="type">char</span> **args)</span>;</span><br><span class="line"><span class="comment">//声明了三个内置命令的函数原型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置命令列表</span></span><br><span class="line"><span class="type">char</span> *builtin_str[] = &#123;</span><br><span class="line">    <span class="string">&quot;cd&quot;</span>,</span><br><span class="line">    <span class="string">&quot;help&quot;</span>,</span><br><span class="line">    <span class="string">&quot;exit&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*builtin_func[]) (<span class="type">char</span> **) = &#123;</span><br><span class="line">    &amp;lsh_cd,</span><br><span class="line">    &amp;lsh_help,</span><br><span class="line">    &amp;lsh_exit</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//builtin_str[]：存储命令名称字符串</span></span><br><span class="line"><span class="comment">//builtin_func[]：存储对应的函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_num_builtins</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(builtin_str) / <span class="keyword">sizeof</span>(<span class="type">char</span> *);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态计算内置命令的数量，这样添加新命令时不需要手动修改计数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_cd</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(args[<span class="number">1</span>] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh: expected argument to \&quot;cd\&quot;\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(chdir(args[<span class="number">1</span>]) != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;lsh&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    检查是否有参数（args[1]）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    使用 chdir() 系统调用切换目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    错误处理：目录不存在或权限不足时显示错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_help</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stephen Brennan&#x27;s LSH\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type program names and arguments,and hit enter.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The following are built in:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lsh_num_builtins();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %s\n&quot;</span>,builtin_str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Use the man command for information on other programs.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    显示 shell 信息和用法</span></span><br><span class="line"><span class="comment">//    动态列出所有内置命令（使用循环遍历 builtin_str）</span></span><br><span class="line"><span class="comment">//    提示用户使用 man 查看其他程序帮助</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_exit</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    返回 0，在外层循环中通常用于终止 shell</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行函数lsh_execute</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_execute</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(args[<span class="number">0</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//空指令，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; lsh_num_builtins();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(args[<span class="number">0</span>],builtin_str[i]) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (*builtin_func[i])(args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有内置命令（如 cd, exit, help 等）</span></span><br><span class="line">    <span class="comment">//builtin_str[i]：内置命令名称数组</span></span><br><span class="line">    <span class="comment">//builtin_func[i]：对应的函数指针数组</span></span><br><span class="line">    <span class="comment">//如果找到匹配的内置命令，直接调用对应的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lsh_launch(args);</span><br><span class="line">    <span class="comment">//如果不是内置命令（比如 ls, cat, gcc 等）调用 lsh_launch 来启动外部程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// shell主要执行的函数(其中包含读取，解析，执行函数)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lsh_loop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="type">char</span> *line;    <span class="comment">// 存储用户输入的一行命令</span></span><br><span class="line">  	<span class="type">char</span> **args;   <span class="comment">// 存储分割后的命令参数数组  字符串指针数组，如 [&quot;ls&quot;, &quot;-l&quot;, NULL]</span></span><br><span class="line">  	<span class="type">int</span> status;    <span class="comment">// 存储命令执行状态   0表示正常退出/停止，非0表示继续</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);                    <span class="comment">// 显示提示符</span></span><br><span class="line">        line = lsh_read_line();          <span class="comment">// 读取输入</span></span><br><span class="line">        args = lsh_split_line(line);     <span class="comment">// 解析命令</span></span><br><span class="line">        status = lsh_execute(args);      <span class="comment">// 执行命令</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(line);</span><br><span class="line">        <span class="built_in">free</span>(args);</span><br><span class="line">    &#125; <span class="keyword">while</span> (status); <span class="comment">// // 根据状态决定是否继续循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数(主要执行主要函数并判断返回状态)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">	<span class="comment">// argc：命令行参数个数</span></span><br><span class="line">    <span class="comment">// argv：命令行参数数组（字符串指针数组）</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Run command loop.</span></span><br><span class="line">  lsh_loop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform any shutdown/cleanup.</span></span><br><span class="line">  <span class="comment">// 程序退出前的清理工作，当前只是注释</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">  <span class="comment">//正常退出程序，EXIT_SUCCESS 通常定义为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




















      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/11/shell%E7%BC%96%E5%86%991/" data-id="cuidR_hNFrpUY6isFxGN86PJy" data-title="shell编写" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/10/11/interpretation/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          解释器
        
      </div>
    </a>
  
  
    <a href="/2025/10/10/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/11/interpretation/">解释器</a>
          </li>
        
          <li>
            <a href="/2025/10/11/shell%E7%BC%96%E5%86%991/">shell编写</a>
          </li>
        
          <li>
            <a href="/2025/10/10/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>