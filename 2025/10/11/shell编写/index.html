<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>shell编写 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="今天开始编写一个用c语言写的shell">
<meta property="og:type" content="article">
<meta property="og:title" content="shell编写">
<meta property="og:url" content="http://example.com/2025/10/11/shell%E7%BC%96%E5%86%99/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="今天开始编写一个用c语言写的shell">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-10-11T06:21:43.000Z">
<meta property="article:modified_time" content="2025-10-15T09:21:11.743Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-shell编写" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/11/shell%E7%BC%96%E5%86%99/" class="article-date">
  <time class="dt-published" datetime="2025-10-11T06:21:43.000Z" itemprop="datePublished">2025-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      shell编写
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天开始编写一个用c语言写的shell</p>
<span id="more"></span>

<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>shell的主要做的是三件事：</p>
<ul>
<li>初始化：shell会读取并执行其配置文件</li>
<li>解释：读取命令并执行它们</li>
<li>终止：在执行命令以后，shell会释放内存然后终止</li>
</ul>
<p>但是我现在制作的是最简单的shell，没有自己的配置文件，也不会有关闭命令</p>
<p>因此这个shell只需要不断的调用循环函数，然后终止</p>
<p>首先下面的代码只是一部分，并不可以实现shell(即便是最简单的shell了)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">	<span class="comment">// argc：命令行参数个数</span></span><br><span class="line">    <span class="comment">// argv：命令行参数数组（字符串指针数组）</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Run command loop.</span></span><br><span class="line">  lsh_loop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform any shutdown/cleanup.</span></span><br><span class="line">  <span class="comment">// 程序退出前的清理工作，当前只是注释</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">  <span class="comment">//正常退出程序，EXIT_SUCCESS 通常定义为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中的l s h_l o o p()函数将循环解释命令，以下是实现过程</p>
<hr>
<h2 id="loop函数的实现"><a href="#loop函数的实现" class="headerlink" title="loop函数的实现"></a>loop函数的实现</h2><p>前面的代码只是简单提及了启动的过程，执行loop函数，然后就返回</p>
<p>显而易见核心是loop函数的实现</p>
<p>我们可以思考一下shell会对我们输入的命令做什么：</p>
<ul>
<li><code>read</code>：首先肯定是读取你输入的命令</li>
<li><code>parse</code>：其次就是解析你的命令，如果不解析命令电脑就不理解你输入的命令的含义**(这里的解析命令是把命令分割为程序和参数)**</li>
</ul>
<p>比如命令<code>ls -l</code>这个命令就会被分割为<code>ls</code>和<code>-l</code></p>
<ul>
<li><code>execute</code>：执行解析后的命令</li>
</ul>
<p>这也就是我上面所写的loop函数需要实现的功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lsh_loop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  	<span class="type">char</span> *line;    <span class="comment">// 存储用户输入的一行命令</span></span><br><span class="line">  	<span class="type">char</span> **args;   <span class="comment">// 存储分割后的命令参数数组  字符串指针数组，如 [&quot;ls&quot;, &quot;-l&quot;, NULL]</span></span><br><span class="line">  	<span class="type">int</span> status;    <span class="comment">// 存储命令执行状态   0表示正常退出/停止，非0表示继续</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);                    <span class="comment">// 显示提示符</span></span><br><span class="line">        line = lsh_read_line();          <span class="comment">// 读取输入</span></span><br><span class="line">        args = lsh_split_line(line);     <span class="comment">// 解析命令</span></span><br><span class="line">        status = lsh_execute(args);      <span class="comment">// 执行命令</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(line);</span><br><span class="line">        <span class="built_in">free</span>(args);</span><br><span class="line">    &#125; <span class="keyword">while</span> (status); <span class="comment">// // 根据状态决定是否继续循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="read-line函数"><a href="#read-line函数" class="headerlink" title="read_line函数"></a>read_line函数</h2><p>虽然功能很简单，只是读取你输入的命令，但是用c语言来实现却很麻烦</p>
<p>最难的是你无法提前知道用户会在shell输入多少文本，所以内存的分配是一个问题</p>
<p>这意味着你不可以只是简单的分配一块内存，如果需要的内存超过就需要重新分配更多的内存</p>
<p>实现的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取命令的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSH_RL_BUFSIZE 1024</span></span><br><span class="line"><span class="comment">// 意味着编译器在编译前会把所有LSH_RL_BUFSIZE替换为1024</span></span><br><span class="line"><span class="comment">// 这里表示输入缓冲区的初始大小是 1024 字节</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">lsh_read_line</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bufsize = LSH_RL_BUFSIZE;<span class="comment">//这个变量用于跟踪当前缓冲区的容量</span></span><br><span class="line">    <span class="type">int</span> position = <span class="number">0</span>;<span class="comment">//这个变量用作指针，指示当前在缓冲区中写入字符的位置</span></span><br><span class="line">    <span class="type">char</span> *buffer = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * bufsize);</span><br><span class="line">    <span class="comment">//动态分配bufsize个char大小的内存</span></span><br><span class="line">    <span class="type">int</span> c;<span class="comment">//从下面知道用于存储字符</span></span><br><span class="line">    <span class="comment">//使用int而不是char是因为getchar()返回int,需要能存储 EOF(通常是-1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!buffer)</span><br><span class="line">    <span class="comment">//检查内存分配是否成功 !buffer 等价于 buffer == NULL，如果内存分配失败，malloc 会返回 NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">        <span class="comment">//如果内存分配失败，向标准错误流输出错误信息</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="comment">//立即终止程序执行</span></span><br><span class="line">        <span class="comment">//EXIT_FAILURE：预定义的宏，通常值为 1，表示程序异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = getchar();<span class="comment">//读取一个字符</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//接下来的代码处理文件结束符或换行符的情况</span></span><br><span class="line">        <span class="keyword">if</span>(c == EOF || c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="comment">// EOF 是一个整数，而不是一个字符</span></span><br><span class="line">        <span class="comment">// c == EOF：检查是否是文件结束符（End Of File）</span></span><br><span class="line">        <span class="comment">// c == &#x27;\n&#x27;：检查是否是换行符（用户按了回车键）</span></span><br><span class="line">        &#123;</span><br><span class="line">            buffer[position] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">//buffer[position]：访问缓冲区中 position 位置的字符</span></span><br><span class="line">            <span class="comment">//&#x27;\0&#x27;：空字符，ASCII 值为 0，表示 C 字符串的结束</span></span><br><span class="line">            <span class="keyword">return</span> buffer;</span><br><span class="line">            <span class="comment">//将包含用户输入字符串的缓冲区返回给调用者</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            buffer[position] = c;</span><br><span class="line">            <span class="comment">//将读取的字符存储到缓冲区的当前位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        position++;</span><br><span class="line">        <span class="comment">//将位置指针向后移动一位，为下一个字符做准备</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来的代码处理缓冲区溢出的情况</span></span><br><span class="line">    <span class="keyword">if</span>(position &gt;= bufsize)</span><br><span class="line">    <span class="comment">//检查当前位置是否达到或超过当前缓冲区容量</span></span><br><span class="line">    &#123;</span><br><span class="line">        bufsize += LSH_RL_BUFSIZE;</span><br><span class="line">        <span class="comment">//扩大缓冲区容量，每次增加 1024 字节</span></span><br><span class="line">        buffer = <span class="built_in">realloc</span>(buffer,bufsize);<span class="comment">//重新分配内存</span></span><br><span class="line">        <span class="comment">//可能会在新的内存位置重新分配，所以需要更新 buffer 指针</span></span><br><span class="line">        <span class="keyword">if</span>(!buffer)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此函数的核心就是不断的循环读入字符</p>
<p><strong>EOF 是一个整数，而不是一个字符，如果你想检查它，你需要使用 <code>int</code></strong></p>
<p>这很重要，很容易犯错</p>
<p>如果发现读入的字符最后是换行符或者EOF，那就以null终止当前字符并返回，否则就将该字符添加到字符串中</p>
<p>接着我们又会查看下一个字符是否会超出当前的缓冲区大小，如果超出就会重新分配缓冲区</p>
<p>但是实际上在<code>stdio.h</code>的库里有一个<code>getline()</code>的函数可以实现以上代码的大部分工作，所以以下是使用了<code>getline()</code>函数的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read_line函数的另外一种实现</span></span><br><span class="line"><span class="type">char</span>  *<span class="title function_">lsh_read_line</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//getline()函数要求传入的指针初始为 NULL，这样它才会自动分配内存</span></span><br><span class="line">    <span class="type">ssize_t</span> bufsize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ssize_t：有符号大小类型，用于表示大小或字节数</span></span><br><span class="line">    <span class="comment">//设置为 0 表示让 getline() 自动管理缓冲区大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getline(&amp;line,&amp;bufsize,<span class="built_in">stdin</span>) == <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//&amp;line：传递 line 指针的地址，getline() 会修改这个指针</span></span><br><span class="line">    <span class="comment">//&amp;bufsize：传递缓冲区大小的地址，getline() 会更新这个值</span></span><br><span class="line">    <span class="comment">//== -1：检查 getline() 是否执行失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(feof(<span class="built_in">stdin</span>))</span><br><span class="line">        <span class="comment">//检查是否到达文件末尾（End Of File）</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);<span class="comment">//接收到了EOF的情况</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            perror(<span class="string">&quot;readline&quot;</span>);<span class="comment">//输出错误信息</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//异常退出程序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="split-line函数"><a href="#split-line函数" class="headerlink" title="split_line函数"></a>split_line函数</h2><p>在上面，read函数已经做好了，接下来需要的是把读入的命令解析</p>
<p>在我们现在制作的shell中我们添加一个规则，不允许在命令会参数中转义引用或反斜杠，我们只使用空格来分割参数</p>
<p>所以命令<code>echo &quot;this message&quot;</code>并不会打印出<code>this message</code>，而是打印出<code>this</code>和<code>message</code></p>
<p>通过这些简化，我们用空格将他们划分为<code>token</code>，我们可以用标准库中的<code>strtok</code>函数实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析命令的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSH_TOK_BUFSIZE 64</span></span><br><span class="line"><span class="comment">//定义令牌缓冲区的初始大小，设置为 64，表示初始可以存储64个令牌（命令和参数）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSH_TOK_DELIM <span class="string">&quot; \t\r\n\a&quot;</span></span></span><br><span class="line"><span class="comment">//定义分词分隔符字符串包含 空格&quot; &quot; 制表符&quot;\t&quot; 回车&quot;\r&quot; 换行&quot;\n&quot; 响铃&quot;\a&quot;</span></span><br><span class="line"><span class="type">char</span> **<span class="title function_">lsh_split_line</span><span class="params">(<span class="type">char</span> *line)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bufsize = LSH_TOK_BUFSIZE,position = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//bufsize：当前令牌数组的大小，初始为 64</span></span><br><span class="line">    <span class="comment">//position：当前令牌的位置索引，初始为 0</span></span><br><span class="line">    <span class="type">char</span> **tokens = <span class="built_in">malloc</span>(bufsize * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    <span class="type">char</span> *token;</span><br><span class="line">    <span class="comment">//声明字符指针 token，用于存储每次分割得到的令牌</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!tokens)<span class="comment">//检查内存分配是否成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        <span class="comment">//如果内存分配失败，输出错误信息并退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token = strtok(line,LSH_TOK_DELIM);</span><br><span class="line">    <span class="comment">//strtok(line, LSH_TOK_DELIM)：在 line 中查找第一个不被分隔符包含的令牌</span></span><br><span class="line">    <span class="comment">//例如：&quot;ls -l&quot; → &quot;ls&quot;</span></span><br><span class="line">    <span class="keyword">while</span>(token != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="comment">//当还有令牌可分割时继续循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        tokens[position] = token;</span><br><span class="line">        <span class="comment">//将当前令牌存储到令牌数组中</span></span><br><span class="line">        position++;</span><br><span class="line">        <span class="comment">//位置索引加1，指向下一个空位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(position &gt;= bufsize)<span class="comment">//检查是否超出当前缓冲区容量</span></span><br><span class="line">        &#123;</span><br><span class="line">            bufsize += LSH_TOK_BUFSIZE;</span><br><span class="line">            <span class="comment">//增加缓冲区大小，每次增加 64 个令牌位置</span></span><br><span class="line">            tokens = <span class="built_in">realloc</span>(tokens,bufsize * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">            <span class="comment">//重新分配更大的内存空间</span></span><br><span class="line">            <span class="keyword">if</span>(!tokens)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;lsh:allocation error\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;<span class="comment">//检查重新分配是否成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        token = strtok(<span class="literal">NULL</span>,LSH_TOK_DELIM);</span><br><span class="line">        <span class="comment">//继续分割下一个令牌</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tokens[position] = <span class="literal">NULL</span>;<span class="comment">//在令牌数组末尾添加 NULL 指针，标记数组结束</span></span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段代码和read_line函数非常相似，因为我们使用的相同的策略，也就是拥有缓冲区并动态扩展</p>
<p>但是这一次，我们使用null结尾的指针数组而不是以null结尾的字符数组 来执行操作</p>
<p>在函数开始时，我们通过对<code>strtok</code>函数的调用返回第一个标记的地址，实际上返回的是你给的字符串的地址，且用’\0’放置在每个标记的末尾，</p>
<p>将每个指针存储在字符指针的数组（缓冲区）中</p>
<p>最后，如果有必要，我们可以重新分配字指针数组。重复整个过程直到<code>strtok</code>没有返回任何标记，此时终止读取</p>
<p>最后我们会得到一系列token和存储它的数组(<code>tokens</code>)，接下来就需要执行</p>
<hr>
<h2 id="shell如何启动进程"><a href="#shell如何启动进程" class="headerlink" title="shell如何启动进程"></a>shell如何启动进程</h2><p>现在我们已经来到了shell的核心问题：启动进程</p>
<p>写一个shell意味着我们需要清楚进程发生了什么还有它是如何开始的</p>
<p>所以接下来需要讨论一下类Unix系统中的进程</p>
<p>在Unix上启动进程只要两种方法，第一种(几乎不算)是<code>Init</code>，当Unix计算机启动时，它的内核被加载。当它的内核被加载并初始化时，内核只启动一个进程，这称为<code>Init</code>。这个进程在计算机打开的整个时间长度内运行，并管理加载计算机剩余的计算机有用的进程</p>
<p>因为大部分的程序都不是<code>Init</code>，所以只有一种另外一种启动进程的方式：<code>fork()</code>系统调用</p>
<p>调用此函数事时，操作系统会复制该进程并启动它们运行，原来的进程被称为“父进程”，新的进程被称为“子进程”。</p>
<p><code>fork()</code>会向子进程返回0，并将子进程的进程PID返回给父进程</p>
<p>从本质上讲，这意味着启动新进程的方式就是复制现有的进程</p>
<p>这听起来可能有些问题，典型的，当你想要运行一个新的进程时，你并不仅仅想要运行一个一样的进程，而是运行一个不一样的程序，这就是<code>exec()</code>系统调用的意义所在。</p>
<p>它用一个全新的程序替换了当前正在运行的程序，这意味着当你调用<code>exec()</code>时，操作系统将停止你的进程，加载新的程序，并在其位置启动该程序。进程不会从调用中返回（除非它发生了错误）</p>
<p>通过这两种系统调用，我们有了大多数程序在<code>Unic</code>上运行的基本要素。首先一个现有的进程分为两个的部分，然后子进程使用<code>exec()</code>将自己替换成一个新的进程，父进程可以继续做其他的事情，甚至可以通过系统调用<code>wait()</code>继续对子进程进行访问</p>
<p>接下来就是用于启动进程并执行外部命令的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统调用函数 创建子进程来执行外部命令</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lsh_launch</span><span class="params">(<span class="type">char</span> **args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid,wpid;<span class="comment">//进程ID变量</span></span><br><span class="line">    <span class="type">int</span> status;<span class="comment">//子进程状态</span></span><br><span class="line"></span><br><span class="line">    pid = fork();<span class="comment">//使用 fork() 系统调用创建子进程</span></span><br><span class="line">    <span class="comment">//返回值：</span></span><br><span class="line">    <span class="comment">//0：在子进程中</span></span><br><span class="line">    <span class="comment">//&gt;0：在父进程中（返回子进程PID）</span></span><br><span class="line">    <span class="comment">//&lt;0：fork失败</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="keyword">if</span>(execvp(args[<span class="number">0</span>],args) == <span class="number">-1</span>)</span><br><span class="line">    <span class="comment">//使用execvp()执行命令 args[0]：命令名(如 &quot;ls&quot;)</span></span><br><span class="line">    <span class="comment">//args：参数数组（如 [&quot;ls&quot;, &quot;-l&quot;, NULL]）</span></span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;lsh&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//如果执行失败，打印错误并退出</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt;<span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;lsh&quot;</span>);<span class="comment">//fork失败并打印错误信息</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            wpid = waitpid(pid,&amp;status,WUNTRACED);</span><br><span class="line">            <span class="comment">//pid：等待的特定子进程</span></span><br><span class="line">            <span class="comment">//&amp;status：存储子进程状态</span></span><br><span class="line">            <span class="comment">//WUNTRACED：也返回已停止的子进程状态</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));</span><br><span class="line">        <span class="comment">//循环条件：直到子进程正常退出或被信号终止</span></span><br><span class="line">        <span class="comment">//WIFEXITED(status)：子进程正常退出</span></span><br><span class="line">        <span class="comment">//WIFSIGNALED(status)：子进程被信号终止</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在这个函数将使用我们前面解析的参数列表，然后分叉这个进程，并保存返回值(PID)，当<code>fork()</code>成功返回时，此时我们有两个进程并发运行</p>
<p>子进程就会加入if判断的第一种情况(即PID &#x3D;&#x3D; 0)</p>
<p>在子进程中我们希望能够运行用户的命令，所以我们使用<code>exec()</code>系统调用的变种之一<code>execvp</code>，<code>exec</code>的变种的实现效果都是不同的，有些需要可变数量的字符串参数，有些需要使用字符串列表，还有一些允许你指定运行进程的环境</p>
<p>这个特定的变体<code>execvp</code>需要一个程序名称和一个字符串参数的数组(第一个参数必须是程序的名称，而不应该是程序的文件路径)，当我们将程序名称传递给它，操作系统会在系统文件路径去查询它</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/11/shell%E7%BC%96%E5%86%99/" data-id="cuidPGbdDDNdqqXsEOilSPy8Z" data-title="shell编写" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/10/11/%E7%BC%96%E8%BE%91%E5%99%A81/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          编辑器1
        
      </div>
    </a>
  
  
    <a href="/2025/10/10/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/11/%E7%BC%96%E8%BE%91%E5%99%A81/">编辑器1</a>
          </li>
        
          <li>
            <a href="/2025/10/11/shell%E7%BC%96%E5%86%99/">shell编写</a>
          </li>
        
          <li>
            <a href="/2025/10/10/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>